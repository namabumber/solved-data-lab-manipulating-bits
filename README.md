Download Link: https://assignmentchef.com/product/solved-data-lab-manipulating-bits
<br>
<strong>1 Introduction</strong>The purpose of this assignment is to become more familiar with bit-level representations of integers andfloating point numbers. You’ll do this by solving a series of programming “puzzles.” Many of these puzzlesare quite artificial, but you’ll find yourself thinking much more about bits in working your way throughthem.<strong>2 Logistics</strong>This is an individual project. All handins are electronic. Clarifications and corrections will be posted on thecourse Web page.<strong>3 Handout Instructions</strong>SITE-SPECIFIC: Insert a paragraph here that explains how the instructor will hand outthe datalab-handout.tar file to the students.Start by copying datalab-handout.tar to a (protected) directory on a Linux machine in which youplan to do your work. Then give the commandunix&gt; tar xvf datalab-handout.tar.This will cause a number of files to be unpacked in the directory. The only file you will be modifying andturning in is bits.c.

The bits.c file contains a skeleton for each of the 15 programming puzzles. Your assignment is tocomplete each function skeleton using only straightline code for the integer puzzles (i.e., no loops or conditionals)and a limited number of C arithmetic and logical operators. Specifically, you are only allowed touse the following eight operators:! ˜ &amp; ˆ | + &lt;&lt; &gt;&gt;A few of the functions further restrict this list. Also, you are not allowed to use any constants longer than 8bits. See the comments in bits.c for detailed rules and a discussion of the desired coding style.<strong>4 The Puzzles</strong>This section describes the puzzles that you will be solving in bits.c.<strong>4.1 Bit Manipulations</strong>Table 1 describes a set of functions that manipulate and test sets of bits. The “Rating” field gives thedifficulty rating (the number of points) for the puzzle, and the “Max ops” field gives the maximum numberof operators you are allowed to use to implement each function. See the comments in bits.c for moredetails on the desired behavior of the functions. You may also refer to the test functions in tests.c. Theseare used as reference functions to express the correct behavior of your functions, although they don’t satisfythe coding rules for your functions.Name Description Rating Max OpsbitAnd(x,y) x &amp; y using only | and ˜ 1 8getByte(x,n) Get byte n from x. 2 6logicalShift(x,n) Shift right logical. 3 20bitCount(x) Count the number of 1’s in x. 4 40bang(x) Compute !n without using ! operator. 4 12Table 1: Bit-Level Manipulation Functions.<strong>4.2 Two’s Complement Arithmetic</strong>Table 2 describes a set of functions that make use of the two’s complement representation of integers. Again,refer to the comments in bits.c and the reference versions in tests.c for more information.4.3 Floating-Point OperationsFor this part of the assignment, you will implement some common single-precision floating-point operations.In this section, you are allowed to use standard control structures (conditionals, loops), and you may

Name Description Rating Max Opstmin() Most negative two’s complement integer 1 4fitsBits(x,n) Does x fit in n bits? 2 15divpwr2(x,n) Compute x/2n 2 15negate(x) -x without negation 2 5isPositive(x) x &gt; 0? 3 8isLessOrEqual(x,y) x &lt;= y? 3 24ilog2(x) Compute ⌊log2(x)⌋ 4 90Table 2: Arithmetic Functionsuse both int and unsigned data types, including arbitrary unsigned and integer constants. You maynot use any unions, structs, or arrays. Most significantly, you may not use any floating point data types,operations, or constants. Instead, any floating-point operand will be passed to the function as having typeunsigned, and any returned floating-point value will be of type unsigned. Your code should performthe bit manipulations that implement the specified floating point operations.Table 3 describes a set of functions that operate on the bit-level representations of floating-point numbers.Refer to the comments in bits.c and the reference versions in tests.c for more information.Name Description Rating Max Opsfloat_neg(uf) Compute -f 2 10float_i2f(x) Compute (float) x 4 30float_twice(uf) Computer 2*f 4 30Table 3: Floating-Point Functions. Value f is the floating-point number having the same bit representationas the unsigned integer uf.Functions float_neg and float_twice must handle the full range of possible argument values, includingnot-a-number (NaN) and infinity. The IEEE standard does not specify precisely how to handleNaN’s, and the IA32 behavior is a bit obscure. We will follow a convention that for any function returninga NaN value, it will return the one with bit representation 0x7FC00000.The included program fshow helps you understand the structure of floating point numbers. To compilefshow, switch to the handout directory and type:unix&gt; makeYou can use fshow to see what an arbitrary pattern represents as a floating-point number:unix&gt; ./fshow 2080374784Floating point value 2.658455992e+36Bit Representation 0x7c000000, sign = 0, exponent = f8, fraction = 000000Normalized. 1.0000000000 X 2ˆ(121)

You can also give fshow hexadecimal and floating point values, and it will decipher their bit structure.<strong>5 Evaluation</strong>Your score will be computed out of a maximum of 76 points based on the following distribution:41 Correctness points.30 Performance points.5 Style points.Correctness points. The 15 puzzles you must solve have been given a difficulty rating between 1 and 4, suchthat their weighted sum totals to 41. We will evaluate your functions using the btest program, which isdescribed in the next section. You will get full credit for a puzzle if it passes all of the tests performed bybtest, and no credit otherwise.Performance points. Our main concern at this point in the course is that you can get the right answer.However, we want to instill in you a sense of keeping things as short and simple as you can. Furthermore,some of the puzzles can be solved by brute force, but we want you to be more clever. Thus, for each functionwe’ve established a maximum number of operators that you are allowed to use for each function. This limitis very generous and is designed only to catch egregiously inefficient solutions. You will receive two pointsfor each correct function that satisfies the operator limit.Style points. Finally, we’ve reserved 5 points for a subjective evaluation of the style of your solutions andyour commenting. Your solutions should be as clean and straightforward as possible. Your comments shouldbe informative, but they need not be extensive.Autograding your workWe have included some autograding tools in the handout directory — btest, dlc, and driver.pl —to help you check the correctness of your work.• btest: This program checks the functional correctness of the functions in bits.c. To build anduse it, type the following two commands:unix&gt; makeunix&gt; ./btestNotice that you must rebuild btest each time you modify your bits.c file.You’ll find it helpful to work through the functions one at a time, testing each one as you go. You canuse the -f flag to instruct btest to test only a single function:unix&gt; ./btest -f bitAnd

You can feed it specific function arguments using the option flags -1, -2, and -3:unix&gt; ./btest -f bitAnd -1 7 -2 0xfCheck the file README for documentation on running the btest program.• dlc: This is a modified version of an ANSI C compiler from the MIT CILK group that you can useto check for compliance with the coding rules for each puzzle. The typical usage is:unix&gt; ./dlc bits.cThe program runs silently unless it detects a problem, such as an illegal operator, too many operators,or non-straightline code in the integer puzzles. Running with the -e switch:unix&gt; ./dlc -e bits.ccauses dlc to print counts of the number of operators used by each function. Type ./dlc -helpfor a list of command line options.• driver.pl: This is a driver program that uses btest and dlc to compute the correctness andperformance points for your solution. It takes no arguments:unix&gt; ./driver.plYour instructors will use driver.pl to evaluate your solution.<strong>6 Handin Instructions</strong>SITE-SPECIFIC: Insert text here that tells each student how to hand in their bits.csolution file at your school.<strong>7 Advice</strong>• Don’t include the &lt;stdio.h&gt; header file in your bits.c file, as it confuses dlc and results insome non-intuitive error messages. You will still be able to use printf in your bits.c file fordebugging without including the &lt;stdio.h&gt; header, although gcc will print a warning that youcan ignore.• The dlc program enforces a stricter form of C declarations than is the case for C++ or that is enforcedby gcc. In particular, any declaration must appear in a block (what you enclose in curly braces) beforeany statement that is not a declaration. For example, it will complain about the following code:

int foo(int x){int a = x;a *= 3; /* Statement that is not a declaration */int b = a; /* ERROR: Declaration not allowed here */}<strong>8 The “Beat the Prof” Contest</strong>For fun, we’re offering an optional “Beat the Prof” contest that allows you to compete with other studentsand the instructor to develop the most efficient puzzles. The goal is to solve each Data Lab puzzle using thefewest number of operators. Students who match or beat the instructor’s operator count for each puzzle arewinners!To submit your entry to the contest, type:unix&gt; ./driver.pl -u ‘‘Your Nickname’’Nicknames are limited to 35 characters and can contain alphanumerics, apostrophes, commas, periods,dashes, underscores, and ampersands. You can submit as often as you like. Your most recent submissionwill appear on a real-time scoreboard, identified only by your nickname. You can view the scoreboard bypointing your browser athttp://$SERVER_NAME:$REQUESTD_PORTSITE-SPECIFIC: Replace $SERVER_NAME and $REQUESTD_PORT with the values youset in the ./contest/Contest.pm file.